import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as n,e}from"./app-57970fd2.js";const t="/assets/image-20240306213702402-28f484bc.png",p="/assets/image-20240306215048127-fd2e517a.png",i={},l=e(`<h1 id="java集合" tabindex="-1"><a class="header-anchor" href="#java集合" aria-hidden="true">#</a> JAVA集合</h1><div class="hint-container tip"><p class="hint-container-title">java集合总结</p><p>这里对java中集合总结</p></div><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><h3 id="_1-分类" tabindex="-1"><a class="header-anchor" href="#_1-分类" aria-hidden="true">#</a> 1. 分类</h3><p>Collection集合包含Set、List、Queue<br> Map集合包含HashMap Hashtable SortedMap</p><h3 id="_2-list、set、queue、map的区别" tabindex="-1"><a class="header-anchor" href="#_2-list、set、queue、map的区别" aria-hidden="true">#</a> 2. List、set、Queue、Map的区别？</h3><p>List: 有序可重复<br> Set: 无序不可重复<br> Queue：有序、可重复的<br> Map：key-value, key是无序、不可重复，value是无序、可重复的</p><h3 id="_3-集合底层框架结构" tabindex="-1"><a class="header-anchor" href="#_3-集合底层框架结构" aria-hidden="true">#</a> 3. 集合底层框架结构</h3><h4 id="list-1" tabindex="-1"><a class="header-anchor" href="#list-1" aria-hidden="true">#</a> List</h4><p>ArrayList: Object[] 数组<br> Vector: Object[] 数组<br> LinkedList: 双向链表</p><h4 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h4><p>HashSet(无序，唯一): HashMap<br> LinkedHashSet：LinkedHashMap来实现的<br> TreeSet(有序，唯一): 红黑树</p><h4 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h4><p>HashMap: 1.8之前是数组+链表组成，1.8以后当链表长度大于8，并且数组长度大于64会转换为红黑树<br> Hashtable: 数组+链表组成<br> TreeMap: 红黑树</p><h3 id="_4-arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_4-arraylist和linkedlist的区别" aria-hidden="true">#</a> 4. ArrayList和LinkedList的区别</h3><p>是否线程安全： 都是线程不安全的<br> 底层数据结构： ArrayList底层使用的是object数组；LinkedList底层使用的是双向链表<br> 插入和删除是否受元素位置影响：<br> ArrayList采用数组存储，执行add(E e)是直接追加到末尾，时间复杂度是O(1), 指定位置插入add(int index, E element) 时间复杂度为0(n)<br> LinkedList 采用链表存储，在头尾插入或删除不受元素位置的影响，时间复杂度为O(1), 如果在指定位置i<br> 插入和删除，时间复杂度为O(n)<br> 是否支持快速随机访问：LinkedList不支持随机元素访问，而ArrayList可以通过元素快速获取元素对象 get(int index) 方法</p><h3 id="_5-arraylist的扩容机制" tabindex="-1"><a class="header-anchor" href="#_5-arraylist的扩容机制" aria-hidden="true">#</a> 5. ArrayList的扩容机制</h3><p>题目： ArrayList list = new ArrayList(20);中list扩容了几次？ 答案0次<br> 解答： ArrayList构造方法有三个<br> ArrayList() 构建一个空的数组。1.7默认初始容量为10，1.8只是构造一个空的数组<br> ArrayList(int initialCapacity) 构造一个具有指定初始容量的空数组</p><p>扩容核心代码：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p><p>扩容机制：每次添加元素的时候都会判断是否能够容下，如果不够就会发生扩容，扩容的大小为原大小的<strong>1.5</strong>倍数。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(20);
for(int i=1;i&lt;=50;i++){
    arrayList.add(i);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前20次添加不会发生扩容，当21元素添加时数组容量从20扩容到30，当添加31元素时数组容量从30扩容到45，<br> 当添加46元素时，数组容量从45扩容到67</p><h2 id="set-1" tabindex="-1"><a class="header-anchor" href="#set-1" aria-hidden="true">#</a> Set</h2><h3 id="_1-comparable-和-comparator的区别" tabindex="-1"><a class="header-anchor" href="#_1-comparable-和-comparator的区别" aria-hidden="true">#</a> 1. Comparable 和 Comparator的区别</h3><p>Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序</p><p>Comparable: java.lang包下面，有个compareTo方法 （自然排序固定），如：Collections.sort()<br> Comparator: java.util包下面，有个compare(T o1, T o2) 方法，可定制排序</p><p>总：需要为一个类定义一个默认的比较规则，可以使用Comparable接口。如果我们需要定义多个不同的比较规则或者对已经存在的类进行排序并且无法修改源代码，可以使用Comparator接口</p><h3 id="_2-hashset、linkedhashset、treeset-三者的异同" tabindex="-1"><a class="header-anchor" href="#_2-hashset、linkedhashset、treeset-三者的异同" aria-hidden="true">#</a> 2. HashSet、LinkedHashSet、TreeSet 三者的异同</h3><p>相同：三者都是Set接口的实现类，都能保证元素唯一，并且都不是线程安全<br> 不同：HashSet的底层数据结构是哈希表(基于HashMap实现)，用于不需要保证元素插入和取出顺序场景<br> linkedHashSet的底层是链表和哈希表，用于保证元素的插入和取出满足fifo的场景<br> TreeSet 底层是红黑树，用于支持对元素自定义排序规则场景</p><h2 id="map-1" tabindex="-1"><a class="header-anchor" href="#map-1" aria-hidden="true">#</a> Map</h2><h3 id="_1-hashmap-和-hashtable的区别" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-和-hashtable的区别" aria-hidden="true">#</a> 1. HashMap 和 HashTable的区别</h3><p>线程安全：HashMap线程不安全，hashtable线程安全(方法用synchronized修饰了)， 线程安全推荐用ConcurrentHashMap，因为线程安全问题，所以HashMap要比HashTable效率高</p><p>null值： HashMap可以存储null的key和value, hashtable不允许有null健和null值</p><p>扩容：HashMap默认初始化大小为16，之后每次扩容，容量变为原来的2倍，hashtable默认初始化大小为11，之后每次扩容，容量变为原来的2n+1。</p><p>底层数据结构：1.8以后hashmap采用链表+数组+红黑树(链表长度大于8，数组长度大于64)</p><h3 id="_2、hashset和hashmap区别" tabindex="-1"><a class="header-anchor" href="#_2、hashset和hashmap区别" aria-hidden="true">#</a> 2、HashSet和HashMap区别</h3><p>HashSet 底层就是基于 HashMap 实现的,个别方法是自己特有的</p><h3 id="_3、hashmap和treemap-区别" tabindex="-1"><a class="header-anchor" href="#_3、hashmap和treemap-区别" aria-hidden="true">#</a> 3、HashMap和TreeMap 区别</h3><p>底层数据结构：hashmap使用哈希表，treemap使用红黑树<br> 元素顺序：hashmap不保证元素顺序，treemap会根据健的自然顺序或自定义比较器来对元素进行排序，并保持有序状态<br> 性能：hashmap性能比treemap高<br> 自定义排序：treemap允许根据键的自然顺序或自定义比较器来进行排序</p><h3 id="_4、hashmap底层实现" tabindex="-1"><a class="header-anchor" href="#_4、hashmap底层实现" aria-hidden="true">#</a> 4、HashMap底层实现</h3><p>1.8以前： 数组+链表<br> 1.8以后： 数组+链表+红黑树(链表长度大于8，并且数组长度小于64的时候，会进行数组扩容，而不是转换为红黑树)</p><h3 id="_5、hashmap的长度为什么是2的幂次方" tabindex="-1"><a class="header-anchor" href="#_5、hashmap的长度为什么是2的幂次方" aria-hidden="true">#</a> 5、HashMap的长度为什么是2的幂次方</h3><p>答: 是为了减少hash碰撞，把数据分配均匀,其中数组下标计算方式为(n-1) &amp; hash<br> &amp;：按位与，都为1的时候才为1，举例假设n=8 ,hash 为17<br> 即：7&amp;17<br> 00111<br> 10001<br> 00001<br> 计算结果为1<br> 之所以长度取2的幂次方，是为了保证n-1转换为2进展后对应的都是1， 如：8-1转换2进制=111 16-1转换2进制=1111 32-1转换二进制=11111</p><h3 id="_6、hashmap遍历方式" tabindex="-1"><a class="header-anchor" href="#_6、hashmap遍历方式" aria-hidden="true">#</a> 6、HashMap遍历方式</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Map&lt;Integer,String&gt; map = new HashMap();
(1) map.ketSet
for(Integer key:map.keySet()){
    System.out.println(key);
   System.out.println(map.get(key));
}

备注：使用map.ketSet遍历，for循环第一个参数为map集合的第一个类型

 
(2) map.entrySet
for(Map.Entry&lt;Integer,String&gt; entry: map.entrySet()){
   System.out.println(entry.getKey());
   System.out.println(entry.getValue());
}

备注：使用map.entrySet遍历，for循环第一个参数为Map.Entry&lt;&gt; 泛型里面填上map对应的类型
 
(3).lambda表达式
map.forEach((key,value) -&gt;{
    System.out.println(key);
    System.out.println(value);
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7、concurrenthashmap-和-hashtable的区别" tabindex="-1"><a class="header-anchor" href="#_7、concurrenthashmap-和-hashtable的区别" aria-hidden="true">#</a> 7、ConcurrentHashMap 和 Hashtable的区别</h3><p>底层数据结构：1.7 concurrentHashMap 底层采用分段的数组+链表实现，1.8采用数组+链表+红黑树<br> 线程安全：1.7中 concurrentHashMap 对整个桶数组进行了分割分段(分段锁)，1.8以后改为Node 数组<br> +链表+红黑树的数据结构来实现，并发控制使用synchronized 和cas 来操作</p><h2 id="待更新" tabindex="-1"><a class="header-anchor" href="#待更新" aria-hidden="true">#</a> 待更新</h2><ul class="task-list-container"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> HashMap源码深入分析</label></li></ul><h2 id="hashmap源码分析" tabindex="-1"><a class="header-anchor" href="#hashmap源码分析" aria-hidden="true">#</a> HashMap源码分析</h2><h3 id="_1-数组和链表的优缺点" tabindex="-1"><a class="header-anchor" href="#_1-数组和链表的优缺点" aria-hidden="true">#</a> 1.数组和链表的优缺点</h3><ul><li><p>数组</p><ul><li>优点 <ul><li>随机访问：支持通过索引快速访问，时间复杂度为O(1)</li></ul></li><li>缺点 <ul><li>大小固定：一旦定义，数组的大小通常不容易改变</li><li>插入和删除操作成本高： 插入和删除元素时可能需要移动大量元素，复杂度为0(n)</li></ul></li></ul></li><li><p>链表</p><ul><li>优点 <ul><li>动态大小：链表的大小可以根据需要动态增长和缩减</li><li>插入和删除效率高：在已知节点的情况下，向链表中插入或删除一个节点只需改变相应的指针，时间复杂度为O(1)</li></ul></li><li>缺点 <ul><li>随机访问较慢：与数组相比，链表不支持直接通过索引快速访问元素，访问任意位置的元素平均需要O(n)的时间</li></ul></li></ul></li></ul><h3 id="_2-有没有一种方式整合上面两种数据结构的优势" tabindex="-1"><a class="header-anchor" href="#_2-有没有一种方式整合上面两种数据结构的优势" aria-hidden="true">#</a> 2. 有没有一种方式整合上面两种数据结构的优势？</h3><ul><li><p>散列表，也称hash</p><figure><img src="`+t+'" alt="image-20240306213702402" tabindex="0" loading="lazy"><figcaption>image-20240306213702402</figcaption></figure></li><li><p>hash的核心理论</p><ul><li>就是把任意长度的输入，通过hash算法变成固定长度的输出。</li></ul></li><li><p>Hash的特点</p><ul><li>从hash值不可以反向推导出原始的数据</li><li>输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值</li><li>哈希算法的执行效率要高效，长的文本也能快速地计算出哈希值</li><li>hash算法的冲突概率要小</li><li>注意：由于hash的原理是将输入空间的值映射成hash空间内，而hash值的空间远小于输入的空间，因此一定会存在不同的输入被映射成相同输出的情况</li></ul></li></ul><h3 id="_3-hashmap-底层数据结构" tabindex="-1"><a class="header-anchor" href="#_3-hashmap-底层数据结构" aria-hidden="true">#</a> 3. hashmap 底层数据结构？</h3><figure><img src="'+p+`" alt="image-20240306215048127" tabindex="0" loading="lazy"><figcaption>image-20240306215048127</figcaption></figure><h3 id="_4-put数据原理分析" tabindex="-1"><a class="header-anchor" href="#_4-put数据原理分析" aria-hidden="true">#</a> 4. put数据原理分析？</h3><ol><li>put key value值</li><li>计算key的hash值</li><li>经过hash值扰动函数，使此hash值更散列</li><li>构建出node对象</li><li>路由算法，找出node应存放在数组的位置 <ul><li>（table.length -1）&amp; node.hash</li></ul></li></ol><h3 id="_5-什么是哈希碰撞" tabindex="-1"><a class="header-anchor" href="#_5-什么是哈希碰撞" aria-hidden="true">#</a> 5. 什么是哈希碰撞？</h3><ul><li>经过hash运算后得到的值一样</li><li>带来的问题 <ul><li>会使得链表越来越长，get起来性能变差</li></ul></li></ul><h3 id="_6-为啥引入红黑树" tabindex="-1"><a class="header-anchor" href="#_6-为啥引入红黑树" aria-hidden="true">#</a> 6. 为啥引入红黑树</h3><ul><li>解决链化很长的问题</li></ul><h3 id="_7-hashmap-扩容原理" tabindex="-1"><a class="header-anchor" href="#_7-hashmap-扩容原理" aria-hidden="true">#</a> 7. hashmap 扩容原理？</h3><ul><li>扩容触发条件 <ul><li>当hashmap中的元素数量超过当前容量乘以0.75的值时候，会发生扩容</li></ul></li><li>扩容通常是扩大原来数量的2倍</li></ul><h3 id="_8-hashmap源码之-类的属性" tabindex="-1"><a class="header-anchor" href="#_8-hashmap源码之-类的属性" aria-hidden="true">#</a> 8. hashmap源码之-类的属性</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
    <span class="token comment">// 序列号</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">362498820763181265L</span><span class="token punctuation">;</span>
    <span class="token comment">// 默认的初始容量是16</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">// 最大容量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token comment">// 默认的负载因子</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
    <span class="token comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
    <span class="token comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">UNTREEIFY_THRESHOLD</span> <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token comment">// 桶中结构转化为红黑树对应的table的最小容量,当数组长度大于64时才会转换红黑树</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
    <span class="token comment">// 存储元素的数组，总是2的幂次倍</span>
    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
    <span class="token comment">// 存放具体元素的集</span>
    <span class="token keyword">transient</span> <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token punctuation">&lt;</span>k<span class="token punctuation">,</span>v<span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> entrySet<span class="token punctuation">;</span>
    <span class="token comment">// 存放元素的个数，注意这个不等于数组的长度。</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
    <span class="token comment">// 每次扩容和更改map结构的计数器</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>
    <span class="token comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span>
    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
    <span class="token comment">// 负载因子</span>
    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_9-hashmap源码之-类的构造方法" tabindex="-1"><a class="header-anchor" href="#_9-hashmap源码之-类的构造方法" aria-hidden="true">#</a> 9. hashmap源码之-类的构造方法</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token comment">// 默认构造函数。</span>
    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span> <span class="token comment">// all   other fields defaulted</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// 包含另一个“Map”的构造函数</span>
     <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>
         <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//下面会分析到这个方法</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// 指定“容量大小”的构造函数</span>
     <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token comment">// 指定“容量大小”和“负载因子”的构造函数</span>
     <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal initial capacity: &quot;</span> <span class="token operator">+</span> initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>
             initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>
             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Illegal load factor: &quot;</span> <span class="token operator">+</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>
         <span class="token comment">// 初始容量暂时存放到 threshold ，在resize中再赋值给 newCap 进行table初始化</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>


注意： tableSizeFor 将其扩容到与 initialCapacity 最接近的 <span class="token number">2</span> 的幂次方大小
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,68),c=[l];function o(r,d){return s(),n("div",null,c)}const k=a(i,[["render",o],["__file","javaCollect.html.vue"]]);export{k as default};
