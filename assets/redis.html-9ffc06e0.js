const e=JSON.parse('{"key":"v-49f8d501","path":"/technology/java/redis.html","title":"Redis","lang":"zh-CN","frontmatter":{"icon":"Redis","order":7,"date":"2024-02-20T00:00:00.000Z","category":["使用指南"],"tag":["redis"],"description":"Redis Redis知识梳理 1. redis 为什么这么快 redis 基于内存，内存的访问速度是磁盘的上千倍 redis 基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和io多路复用 redis 内置了多种优化过后的数据类型/结构实现，性能非常高 2. redis的应用 分布式锁 redisson 限流 redis + lua脚本的方式实现了限流 消息队列 缓存 复杂业务场景 比如通过bitmap统计活跃用户 通过sorted set维护排行榜","head":[["meta",{"property":"og:url","content":"https://blog.cx985.top/technology/java/redis.html"}],["meta",{"property":"og:site_name","content":"辰晨沉"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis Redis知识梳理 1. redis 为什么这么快 redis 基于内存，内存的访问速度是磁盘的上千倍 redis 基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和io多路复用 redis 内置了多种优化过后的数据类型/结构实现，性能非常高 2. redis的应用 分布式锁 redisson 限流 redis + lua脚本的方式实现了限流 消息队列 缓存 复杂业务场景 比如通过bitmap统计活跃用户 通过sorted set维护排行榜"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-21T09:57:13.000Z"}],["meta",{"property":"article:author","content":"辰晨沉"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2024-02-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-21T09:57:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-21T09:57:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"辰晨沉\\"}]}"]]},"headers":[{"level":2,"title":"Redis知识梳理","slug":"redis知识梳理","link":"#redis知识梳理","children":[]},{"level":2,"title":"1. redis 为什么这么快","slug":"_1-redis-为什么这么快","link":"#_1-redis-为什么这么快","children":[]},{"level":2,"title":"2. redis的应用","slug":"_2-redis的应用","link":"#_2-redis的应用","children":[]},{"level":2,"title":"3. redis的数据类型","slug":"_3-redis的数据类型","link":"#_3-redis的数据类型","children":[{"level":3,"title":"1. String(字符串)","slug":"_1-string-字符串","link":"#_1-string-字符串","children":[]},{"level":3,"title":"2. List(列表)","slug":"_2-list-列表","link":"#_2-list-列表","children":[]},{"level":3,"title":"3. Set(集合)","slug":"_3-set-集合","link":"#_3-set-集合","children":[]},{"level":3,"title":"4. Hash(散列)","slug":"_4-hash-散列","link":"#_4-hash-散列","children":[]},{"level":3,"title":"5. Zset(有序集合)","slug":"_5-zset-有序集合","link":"#_5-zset-有序集合","children":[]},{"level":3,"title":"6. HyperLogLog(基数统计)","slug":"_6-hyperloglog-基数统计","link":"#_6-hyperloglog-基数统计","children":[]},{"level":3,"title":"7. Bitmap (位图)","slug":"_7-bitmap-位图","link":"#_7-bitmap-位图","children":[]},{"level":3,"title":"8. Geospatial (地理位置)","slug":"_8-geospatial-地理位置","link":"#_8-geospatial-地理位置","children":[]}]},{"level":2,"title":"4.  redis 如何判断数据是否过期？","slug":"_4-redis-如何判断数据是否过期","link":"#_4-redis-如何判断数据是否过期","children":[{"level":3,"title":"1. 立刻删除","slug":"_1-立刻删除","link":"#_1-立刻删除","children":[]},{"level":3,"title":"2. 惰性删除","slug":"_2-惰性删除","link":"#_2-惰性删除","children":[]},{"level":3,"title":"3. 定期删除","slug":"_3-定期删除","link":"#_3-定期删除","children":[]},{"level":3,"title":"4. 总结","slug":"_4-总结","link":"#_4-总结","children":[]}]},{"level":2,"title":"5. redis 内存淘汰机制了解么？","slug":"_5-redis-内存淘汰机制了解么","link":"#_5-redis-内存淘汰机制了解么","children":[{"level":3,"title":"1. redis默认内存多少？在哪查看？如何设置修改？","slug":"_1-redis默认内存多少-在哪查看-如何设置修改","link":"#_1-redis默认内存多少-在哪查看-如何设置修改","children":[]},{"level":3,"title":"2. redis 缓存淘汰策略","slug":"_2-redis-缓存淘汰策略","link":"#_2-redis-缓存淘汰策略","children":[]}]},{"level":2,"title":"6. 布隆过滤器","slug":"_6-布隆过滤器","link":"#_6-布隆过滤器","children":[]},{"level":2,"title":"7. 缓存雪崩+缓存击穿+缓存穿透","slug":"_7-缓存雪崩-缓存击穿-缓存穿透","link":"#_7-缓存雪崩-缓存击穿-缓存穿透","children":[{"level":3,"title":"1. 缓存雪崩","slug":"_1-缓存雪崩","link":"#_1-缓存雪崩","children":[]},{"level":3,"title":"2. 缓存穿透","slug":"_2-缓存穿透","link":"#_2-缓存穿透","children":[]},{"level":3,"title":"3. 缓存击穿","slug":"_3-缓存击穿","link":"#_3-缓存击穿","children":[]}]},{"level":2,"title":"8. redis分布锁","slug":"_8-redis分布锁","link":"#_8-redis分布锁","children":[{"level":3,"title":"1. 一个靠谱的分布锁锁需要具备的条件和刚需","slug":"_1-一个靠谱的分布锁锁需要具备的条件和刚需","link":"#_1-一个靠谱的分布锁锁需要具备的条件和刚需","children":[]},{"level":3,"title":"2. 为啥要上分布锁？","slug":"_2-为啥要上分布锁","link":"#_2-为啥要上分布锁","children":[]},{"level":3,"title":"3. redisson使用场景","slug":"_3-redisson使用场景","link":"#_3-redisson使用场景","children":[]},{"level":3,"title":"4. redisson的看门狗缓存续命了解么？","slug":"_4-redisson的看门狗缓存续命了解么","link":"#_4-redisson的看门狗缓存续命了解么","children":[]}]},{"level":2,"title":"9. 数据双写一致性问题","slug":"_9-数据双写一致性问题","link":"#_9-数据双写一致性问题","children":[{"level":3,"title":"1. 缓存双写一致性，谈谈你的理解？","slug":"_1-缓存双写一致性-谈谈你的理解","link":"#_1-缓存双写一致性-谈谈你的理解","children":[]},{"level":3,"title":"2. 缓存操作分类","slug":"_2-缓存操作分类","link":"#_2-缓存操作分类","children":[]},{"level":3,"title":"3 .缓存一致性几种更新策略","slug":"_3-缓存一致性几种更新策略","link":"#_3-缓存一致性几种更新策略","children":[]}]},{"level":2,"title":"10 . redis经典五种数据类型底层实现","slug":"_10-redis经典五种数据类型底层实现","link":"#_10-redis经典五种数据类型底层实现","children":[{"level":3,"title":"1. 查看类型和编码命令","slug":"_1-查看类型和编码命令","link":"#_1-查看类型和编码命令","children":[]},{"level":3,"title":"2. String底层结构","slug":"_2-string底层结构","link":"#_2-string底层结构","children":[]},{"level":3,"title":"3. hash底层结构","slug":"_3-hash底层结构","link":"#_3-hash底层结构","children":[]},{"level":3,"title":"4. list底层结构","slug":"_4-list底层结构","link":"#_4-list底层结构","children":[]},{"level":3,"title":"5. Set底层结构","slug":"_5-set底层结构","link":"#_5-set底层结构","children":[]},{"level":3,"title":"6. ZSet底层结构","slug":"_6-zset底层结构","link":"#_6-zset底层结构","children":[]},{"level":3,"title":"7. 跳表","slug":"_7-跳表","link":"#_7-跳表","children":[]}]},{"level":2,"title":"11. redis 持久化","slug":"_11-redis-持久化","link":"#_11-redis-持久化","children":[{"level":3,"title":"1. 持久化方式","slug":"_1-持久化方式","link":"#_1-持久化方式","children":[]},{"level":3,"title":"2. RDB创建快照时会阻塞主线程吗？","slug":"_2-rdb创建快照时会阻塞主线程吗","link":"#_2-rdb创建快照时会阻塞主线程吗","children":[]},{"level":3,"title":"3 . AOF持久化","slug":"_3-aof持久化","link":"#_3-aof持久化","children":[]},{"level":3,"title":"4 . 如何选择RDB 和AOF?","slug":"_4-如何选择rdb-和aof","link":"#_4-如何选择rdb-和aof","children":[]}]},{"level":2,"title":"12. redis的I/O多路复用模型","slug":"_12-redis的i-o多路复用模型","link":"#_12-redis的i-o多路复用模型","children":[{"level":3,"title":"1. 是什么？","slug":"_1-是什么","link":"#_1-是什么","children":[]},{"level":3,"title":"2. 概念","slug":"_2-概念","link":"#_2-概念","children":[]},{"level":3,"title":"3. I/O多路复用","slug":"_3-i-o多路复用","link":"#_3-i-o多路复用","children":[]},{"level":3,"title":"4. select","slug":"_4-select","link":"#_4-select","children":[]},{"level":3,"title":"5. poll","slug":"_5-poll","link":"#_5-poll","children":[]},{"level":3,"title":"6. epoll","slug":"_6-epoll","link":"#_6-epoll","children":[]}]},{"level":2,"title":"13. redis集群","slug":"_13-redis集群","link":"#_13-redis集群","children":[{"level":3,"title":"1. redis 哨兵","slug":"_1-redis-哨兵","link":"#_1-redis-哨兵","children":[]},{"level":3,"title":"2. redis集群","slug":"_2-redis集群","link":"#_2-redis集群","children":[]}]},{"level":2,"title":"14. redis的大key","slug":"_14-redis的大key","link":"#_14-redis的大key","children":[{"level":3,"title":"1. 排查大key","slug":"_1-排查大key","link":"#_1-排查大key","children":[]},{"level":3,"title":"2. 处理方法","slug":"_2-处理方法","link":"#_2-处理方法","children":[]}]},{"level":2,"title":"15. redis事物","slug":"_15-redis事物","link":"#_15-redis事物","children":[{"level":3,"title":"1. redis事物支持原子性吗","slug":"_1-redis事物支持原子性吗","link":"#_1-redis事物支持原子性吗","children":[]},{"level":3,"title":"2. redis事物有什么缺陷","slug":"_2-redis事物有什么缺陷","link":"#_2-redis事物有什么缺陷","children":[]},{"level":3,"title":"3. 解决方案？","slug":"_3-解决方案","link":"#_3-解决方案","children":[]}]}],"git":{"createdTime":1704805555000,"updatedTime":1713693433000,"contributors":[{"name":"chenxin","email":"1690273757@qq.com","commits":4}]},"readingTime":{"minutes":32.1,"words":9629},"filePathRelative":"technology/java/redis.md","localizedDate":"2024年2月20日","excerpt":"<h1> Redis</h1>\\n<h2> Redis知识梳理</h2>\\n<h2> 1. redis 为什么这么快</h2>\\n<ul>\\n<li>redis 基于内存，内存的访问速度是磁盘的上千倍</li>\\n<li>redis 基于Reactor模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和io多路复用</li>\\n<li>redis 内置了多种优化过后的数据类型/结构实现，性能非常高</li>\\n</ul>\\n<h2> 2. redis的应用</h2>\\n<ul>\\n<li>分布式锁\\n<ul>\\n<li>redisson</li>\\n</ul>\\n</li>\\n<li>限流\\n<ul>\\n<li>redis + lua脚本的方式实现了限流</li>\\n</ul>\\n</li>\\n<li>消息队列</li>\\n<li>缓存</li>\\n<li>复杂业务场景\\n<ul>\\n<li>比如通过bitmap统计活跃用户</li>\\n<li>通过sorted set维护排行榜</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
