const e=JSON.parse('{"key":"v-91800b4a","path":"/technology/java/jvm.html","title":"jvm","lang":"zh-CN","frontmatter":{"icon":"JVM","order":5,"date":"2024-01-10T00:00:00.000Z","category":["使用指南"],"tag":["jvm"],"description":"jvm jvm知识梳理 1. 整体图 image-20240110203713386 2. 解释说明 2.1. 类加载器 负责加载class文件，class文件在文件开头有特定的文件标识（cafe babe），将class文件 字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader 只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 虚拟机自带的加载器 1.启动类加载器（BootStrap） 2.扩展类加载器（Extension） 3.应用程序加载器（AppClassLoader） 双亲委派？ 往上捅，理解为我爸是李刚，有事找我爸，当一个类收到类加载请求，他不会自己去加载这个类， 而是把这个请求委派给父类完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传 送到启动类加载中，只有当父类无法加载时，子类加载器才会尝试自己去加载","head":[["meta",{"property":"og:url","content":"https://blog.cx985.top/technology/java/jvm.html"}],["meta",{"property":"og:site_name","content":"辰晨沉"}],["meta",{"property":"og:title","content":"jvm"}],["meta",{"property":"og:description","content":"jvm jvm知识梳理 1. 整体图 image-20240110203713386 2. 解释说明 2.1. 类加载器 负责加载class文件，class文件在文件开头有特定的文件标识（cafe babe），将class文件 字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader 只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 虚拟机自带的加载器 1.启动类加载器（BootStrap） 2.扩展类加载器（Extension） 3.应用程序加载器（AppClassLoader） 双亲委派？ 往上捅，理解为我爸是李刚，有事找我爸，当一个类收到类加载请求，他不会自己去加载这个类， 而是把这个请求委派给父类完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传 送到启动类加载中，只有当父类无法加载时，子类加载器才会尝试自己去加载"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-21T09:57:13.000Z"}],["meta",{"property":"article:author","content":"辰晨沉"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:published_time","content":"2024-01-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-21T09:57:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"jvm\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-21T09:57:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"辰晨沉\\"}]}"]]},"headers":[{"level":2,"title":"jvm知识梳理","slug":"jvm知识梳理","link":"#jvm知识梳理","children":[{"level":3,"title":"1. 整体图","slug":"_1-整体图","link":"#_1-整体图","children":[]},{"level":3,"title":"2. 解释说明","slug":"_2-解释说明","link":"#_2-解释说明","children":[]},{"level":3,"title":"3. 垃圾判别阶段算法","slug":"_3-垃圾判别阶段算法","link":"#_3-垃圾判别阶段算法","children":[]},{"level":3,"title":"4. 垃圾清除阶段算法","slug":"_4-垃圾清除阶段算法","link":"#_4-垃圾清除阶段算法","children":[]},{"level":3,"title":"5. 垃圾回收器分类","slug":"_5-垃圾回收器分类","link":"#_5-垃圾回收器分类","children":[]},{"level":3,"title":"6. 垃圾收集器落地实现","slug":"_6-垃圾收集器落地实现","link":"#_6-垃圾收集器落地实现","children":[]},{"level":3,"title":"7 . STW","slug":"_7-stw","link":"#_7-stw","children":[]},{"level":3,"title":"8. 类加载过程","slug":"_8-类加载过程","link":"#_8-类加载过程","children":[]},{"level":3,"title":"9. jvm常见参数总结","slug":"_9-jvm常见参数总结","link":"#_9-jvm常见参数总结","children":[]},{"level":3,"title":"10. jdk监控和故障工具总结","slug":"_10-jdk监控和故障工具总结","link":"#_10-jdk监控和故障工具总结","children":[]},{"level":3,"title":"11. 性能调优","slug":"_11-性能调优","link":"#_11-性能调优","children":[]}]}],"git":{"createdTime":1704805555000,"updatedTime":1713693433000,"contributors":[{"name":"chenxin","email":"1690273757@qq.com","commits":12}]},"readingTime":{"minutes":29.62,"words":8887},"filePathRelative":"technology/java/jvm.md","localizedDate":"2024年1月10日","excerpt":"<h1> jvm</h1>\\n<h2> jvm知识梳理</h2>\\n<h3> 1. 整体图</h3>\\n<figure><figcaption>image-20240110203713386</figcaption></figure>\\n<h3> 2. 解释说明</h3>\\n<h4> 2.1. 类加载器</h4>\\n<ul>\\n<li>\\n<p>负责加载class文件，class文件在文件开头有特定的文件标识（cafe babe），将class文件 字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader 只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定</p>\\n</li>\\n<li>\\n<p>虚拟机自带的加载器</p>\\n<ul>\\n<li>1.启动类加载器（BootStrap）</li>\\n<li>2.扩展类加载器（Extension）</li>\\n<li>3.应用程序加载器（AppClassLoader）</li>\\n</ul>\\n</li>\\n<li>\\n<p>双亲委派？</p>\\n<ul>\\n<li>往上捅，理解为我爸是李刚，有事找我爸，当一个类收到类加载请求，他不会自己去加载这个类， 而是把这个请求委派给父类完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传 送到启动类加载中，只有当父类无法加载时，子类加载器才会尝试自己去加载</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
