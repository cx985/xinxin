---
icon: interview
order: 7
category:
  - 算法
tag:
  - 数据结构
---

# 数据结构和算法

## 第一章：算法简介

### 1.1 算法的基本概念

#### 1.1.1 什么是算法

​	算法：故名思意，就是指计算方法，指解决一个问题具体的步骤和方法

#### 1.1.2 为什么学习算法

​	提高自己的核心竞争力，提高自己解决问题的能力

### 1.2 算法的特征

- 有穷性：算法必须在能在执行有限个步骤之后终止
- 确切性：算法的每一步骤必须有确切的定义
- 输入项：一个算法有0个或者多个输入
- 输出项：一个算法有一个或多个输出，以反映对输入数据加工后的结果
- 可行性：每个计算步骤都可以在有限时间内完成

### 1.3 算法复杂度

#### 1.3.1 时间复杂度

​	算法的时间复杂度，是指执行算法所需要的计算工作量。

一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做：T(n)=Ο(f(n))。

问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作渐进时间复杂度（Asymptotic Time Complexity）。

#### 1.3.2 空间复杂度

 算法的空间复杂度，是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示



#### 1.3.3 时间复杂度的计算

  



## 第二章：数组问题讲解

 数组：会利用索引来记录每个元素在数组中的位置，索引是从0算起的

### 2.1 两数之和

#### 2.1.1 题目

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素

**示例**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]



#### 2.1.2 方法一：暴力法

```java
public static int[] twoSum(int[] arr,int target){
        for(int i=0;i<arr.length;i++){
            for(int j=i+1;j<arr.length;j++){
                if(arr[i]+arr[j] == target){
                    return new int[]{i,j};
                }
            }
        }
        return new int[]{};
    }


解释：从结果来说，j也可以从0开始，只不过多遍历了几次，两数之和，两个数，正常的最里面的for循环从第一个数的后面开始
```



#### 2.1.3 方法二：哈希表

```java
public static int[] twoSum(int[] arr,int target){
    //创建一个hashmap存储数组元素和对应的索引
    Map<Integer,Integer> map = new HashMap<>();
    
    //遍历数组元素
    for(int i=0; i<arr.length;i++){
        int complement = target - arr[i];
        //检测是否存在与当前元素配对的差值
        if(map.containsKey(complement)){
            //返回两个数的索引
            return new int[]{map.get(complement),i};
        }
        
        //将当前元素和索引存入hashmap中
        map.put(nums[i],i);
    }
    
    //如果没有找到符合条件的两个数，返回空数组
    return new int[0];
}
```



### 2.2 三数之和

#### 2.2.1 题目说明

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示例**:

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：

[

 [-1, 0, 1],

 [-1, -1, 2]

]



#### 2.2.2 解题（推荐双指针法）

1. 将数组排序：首先，对给定的数组进行排序，以便更方便地使用双指针方法。排序的时间复杂度为O(n log n)，其中n是数组的长度。
2. 遍历数组：遍历排序后的数组，在每个位置上选择一个数字作为第一个数（最左边的指针）。
3. 使用双指针查找另外两个数：在选择的第一个数后面的子数组部分中，使用双指针方法来查找另外两个数，使得它们的和等于0减去第一个数。一个指针从第一个数的右边开始移动，即左指针，另一个指针从数组尾部向左移动，即右指针。
4. 调整指针位置：根据双指针所指的三个数之和与目标和比较的结果，调整指针的位置。如果三数之和小于目标和，将左指针向右移动一位；如果三数之和大于目标和，将右指针向左移动一位；如果三数之和等于目标和，将这三个数添加到结果集中。
5. 继续遍历：重复步骤3和步骤4，直到遍历完整个数组。
6. 返回结果：返回找到的所有满足条件的三个数的组合

```java
public List<List<Integer>> threeSum(int[] nums){
int n = nums.length;
List<List<Integer>> result = new ArrayList<>();

// 先对数组进行排序
    Arrays.sort(nums);
    
    for( int i = 0; i < n; i++ ){
        if( nums[i] > 0 )
            break;
        if( i > 0 && nums[i] == nums[i-1] )
            continue;
        // 定义左右指针（索引位置）
        int lp = i + 1;
        int rp = n - 1;
        // 只要左右不重叠，就继续移动指针
        while( lp < rp ){
            int sum = nums[i] + nums[lp] + nums[rp];
            if( sum == 0 ){
                result.add(Arrays.asList(nums[i], nums[lp], nums[rp]));
                lp ++;
                rp --;
                while( lp < rp && nums[lp] == nums[lp - 1] )
                    lp ++;
                while( lp < rp && nums[rp] == nums[rp + 1] )
                    rp --;
            }
            else if( sum < 0 )
                lp ++;
            else
                rp --;
        }
    }
    return result;
}
```





## 第三章：二分查找

## 第四章：字符串问题

## 第五章：滑动窗口问题

## 第六章：链表问题

## 第七章：哈希表

## 第八章：栈和队列

## 第九章：排序算法

## 第十章：二叉树及递归

## 第十一章：贪心算法

## 第十二章：动态规划

## 第十三章: 回溯算法

## 第十四章：深度优先搜索和广度优先搜索

