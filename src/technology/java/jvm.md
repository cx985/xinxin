---
icon: interview
order: 7
date: 2024-01-10
category:
  -  使用指南
tag:
  -  jvm
---

# jvm

## jvm知识梳理

- [ ] 待更新......

### 1. 整体图

![image-20240110203713386](jvm.assets/image-20240110203713386.png)

### 2. 解释说明

#### 2.1. 类加载器

- 负责加载class文件，class文件在文件开头有特定的文件标识（cafe babe），将class文件 字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader 只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 
- 虚拟机自带的加载器 
  - 1.启动类加载器（BootStrap） 
  - 2.扩展类加载器（Extension） 
  - 3.应用程序加载器（AppClassLoader）

- 双亲委派？
  -  往上捅，理解为我爸是李刚，有事找我爸，当一个类收到类加载请求，他不会自己去加载这个类， 而是把这个请求委派给父类完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传 送到启动类加载中，只有当父类无法加载时，子类加载器才会尝试自己去加载        

#### 

#### 2.2. 程序计数器（Program Counter Register） 

-  每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码 （用来存储向下一条指令的地址，也即将要执行的代码），由执行引擎读取下一条指令， 是一个非常小的内存空间，几乎可以忽略不记。 这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个 计数器的值来选取下一条需要执行的字节码指令。 如果执行的是一个Native方法，那这个计数器是空的。 用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。 不会发生内存溢出（OutOfMemory =oom）错误 

#### 2.3. 方法区（Method Area）

-  供各线程共享的运行时内存区域。它存储了每一个类的结构信息。例如 运行时常量池（Runtime Constrant Pool）、字段和方法数据、 构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现 是不一样的，最典型的就是永久代（PermGen space）和元空间（Metaspace）. 但是实例变量存在堆内存中，和方法区无关          



#### 2.4. 栈（stack）

- 先进后出，后进先出 (子弹夹)
- 栈管运行，堆管存储
-  栈也叫栈内存，主管java程序的运行，是在线程创建时创建，它的生命期是随线程的生命期， 线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over, 生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是 在函数的栈内存中分配 
-  栈存储什么？ 
  - 1.本地变量（Local Variables）: 输入参数和输出参数以及方法内的变量 
  - 2.栈操作（Operand Stack）:记录出栈、入栈的操作 
  - 3.栈帧数据（Frame Data）: 包括类文件、方法等待              

- 栈报的错误？

  - 错误  java.lang.StackOverflowError           

  

#### 2.5. 堆（heap） 

-  一个jvm实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后， 需要把类、方法、常变量放在堆内存中，保存所有引用类型的真实信息，以方便执行器执行 ，堆分为三部分  
  - 1.Young Generation Space 新生区    Young/New 
  - 2.Tenure generation space 养老区   Old/Tenure 
  - 3.Permanent Space         永久区   Perm  

-  java7之前？
  -  堆内存逻辑上分为三部分： 新生+养老+永久 新生区： 伊甸区（Eden Space）、 幸存者0区（Survivor 0 Space）、幸存者1区（Survivor 1 Space）              

- java 堆从gc的角度还可以细分为？
  -  新生代（Eden 区、From Survivor区 和To Survivor区）和老年区 新生代比例 8：1：1              

- 如果出现java.lang.OutOfMemoryError: java heap space异常？
  - 1.java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整 
  - 2.代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）              

![image-20240110204942188](jvm.assets/image-20240110204942188.png)



### 3. GC回收四大算法

#### 3.1 引用计数法



#### 3.2 复制算法

- 年轻代
- -XX:MaxTenuringThreshold -- 设置对象在新生代中存活的次数          



#### 3.3 标记清除

-  老年代
- 先标记出要回收的对象，然后统一回收这些对象 



#### 3.4   标记压缩

### 4. 垃圾回收器分类

#### 4.1  串行垃圾回收器

-  Serial   串行垃圾回收器，它为单线程环境设计且只使用一个线程进行垃圾回收，            会暂停所有的用户线程，所以不适合服务器环境  

#### 4.2 并行垃圾回收器 

- Parallel 并行垃圾回收器，多个垃圾收集线程并行工作，此时用户线程是暂停的，            适用于科学计算/大数据处理首页处理等弱交互场景

#### 4.3 并发垃圾收集器

-  CMS  并发垃圾收集器，用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），        不需要停顿用户线程，适用对响应时间有要求的场景

#### 4.4 G1垃圾收集器

- G1  将堆内存分割成不同的区域然后并发的对其进行垃圾回收              

#### 4.5 如何查看默认垃圾收集器

- java -XX:+PrintCommandLineFlags -version 
- 默认并行垃圾收集器                    



### 5. 垃圾收集器落地实现

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现**

![image-20240110211339202](jvm.assets/image-20240110211339202.png)

#### 5.1   Serial 收集器

#### 5.2  ParNew 收集器

####  5.3  Parallel Scavenge 收集器

#### 5.4   Serial Old 收集器

#### 5.5  Parallel Old 收集器 

####  5.6 CMS 收集器

#### 5.7 G1 收集器

#### 5.8 ZGC 收集器





####          

​      

​                                            
