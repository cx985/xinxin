---
icon: interview
order: 7
date: 2024-01-10
category:
  -  使用指南
tag:
  -  jvm
---

# jvm

## jvm知识梳理

- [ ] 待更新......

### 1. 整体图

![image-20240110203713386](jvm.assets/image-20240110203713386.png)

### 2. 解释说明

#### 2.1. 类加载器

- 负责加载class文件，class文件在文件开头有特定的文件标识（cafe babe），将class文件 字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader 只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 
- 虚拟机自带的加载器 
  - 1.启动类加载器（BootStrap） 
  - 2.扩展类加载器（Extension） 
  - 3.应用程序加载器（AppClassLoader）

- 双亲委派？
  -  往上捅，理解为我爸是李刚，有事找我爸，当一个类收到类加载请求，他不会自己去加载这个类， 而是把这个请求委派给父类完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传 送到启动类加载中，只有当父类无法加载时，子类加载器才会尝试自己去加载        

#### 

#### 2.2. 程序计数器（Program Counter Register） 

-  每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码 （用来存储向下一条指令的地址，也即将要执行的代码），由执行引擎读取下一条指令， 是一个非常小的内存空间，几乎可以忽略不记。 这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个 计数器的值来选取下一条需要执行的字节码指令。 如果执行的是一个Native方法，那这个计数器是空的。 用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。 不会发生内存溢出（OutOfMemory =oom）错误 

#### 2.3. 方法区（Method Area）

-  供各线程共享的运行时内存区域。它存储了每一个类的结构信息。例如 运行时常量池（Runtime Constrant Pool）、字段和方法数据、 构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现 是不一样的，最典型的就是永久代（PermGen space）和元空间（Metaspace）. 但是实例变量存在堆内存中，和方法区无关          



#### 2.4. 栈（stack）

- 先进后出，后进先出 (子弹夹)
- 栈管运行，堆管存储
-  栈也叫栈内存，主管java程序的运行，是在线程创建时创建，它的生命期是随线程的生命期， 线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over, 生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是 在函数的栈内存中分配 
-  栈存储什么？ 
  - 1.本地变量（Local Variables）: 输入参数和输出参数以及方法内的变量 
  - 2.栈操作（Operand Stack）:记录出栈、入栈的操作 
  - 3.栈帧数据（Frame Data）: 包括类文件、方法等待              

- 栈报的错误？

  - 错误  java.lang.StackOverflowError           

  

#### 2.5. 堆（heap） 

-  一个jvm实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后， 需要把类、方法、常变量放在堆内存中，保存所有引用类型的真实信息，以方便执行器执行 ，堆分为三部分  
  - 1.Young Generation Space 新生区    Young/New 
  - 2.Tenure generation space 养老区   Old/Tenure 
  - 3.Permanent Space         永久区   Perm  

-  java7之前？
  -  堆内存逻辑上分为三部分： 新生+养老+永久 新生区： 伊甸区（Eden Space）、 幸存者0区（Survivor 0 Space）、幸存者1区（Survivor 1 Space）              

- java 堆从gc的角度还可以细分为？
  -  新生代（Eden 区、From Survivor区 和To Survivor区）和老年区 新生代比例 8：1：1              

- 如果出现java.lang.OutOfMemoryError: java heap space异常？
  - 1.java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整 
  - 2.代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）              

![image-20240110204942188](jvm.assets/image-20240110204942188.png)

#### 2.6 内存分配和回收原则

- 大对象直接进入老年代
- 长期存活的对象将进入老年代

### 3. 垃圾判别阶段算法

#### 3.1 引用计数法

- 给对象添加一个引用计数器
  - 每当有引用+1，引用失效减1
  - 存在循环依赖问题

#### 3.2 可达性分析算法

- 这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收
- 解决循环依赖问题
- **哪些对象可以作为 GC Roots 呢？**
  - 虚拟机栈(栈帧中的局部变量表)中引用的对象
  - 本地方法栈(Native 方法)中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 所有被同步锁持有的对象
  - JNI（Java Native Interface）引用的对象

### 4. 垃圾清除阶段算法

#### 4.1 标记清除（Mark-Sweep）

- 标记：Collector从引用根节点开始遍历，**标记所有被引用的对象**。一般是在对象的Header中记录为可达对象

- 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收

- **很多书、视频讲错了！说是标记的垃圾对象。这里要注意了**

  ![image-20240112141723002](jvm.assets/image-20240112141723002.png)

- 缺点
  - 在进行GC的时候，需要停止整个应用程序
  - **产生内存碎片**

#### 4.2 复制算法

- 年轻代

- -XX:MaxTenuringThreshold -- 设置对象在新生代中存活的次数        

- 将堆内存分为两个区域，每次只使用其中一个区域，当该区域满时，将存活的对象复制到另一个区域，然后清除整个区域。这样可以避免内存碎片问题  

  ![image-20240112142621269](jvm.assets/image-20240112142621269.png)

- 优点
  - 没有标记和清除过程，实现简单，运行高效
  - 复制过去以后保证空间的连续性，不会出现“碎片”问题

- 缺点
  - 需要两倍的内存空间

#### 4.3 标记压缩

- 适用于老年代

- 背景

  - 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法

  - 标记－清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM 的设计者需要在此基础之上进行改进。标记 - 压缩（Mark - Compact）算法由此诞生

    

- 执行过程

  - 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象

  - 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放

  - 最后，清理边界外所有的空间

  - 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-Compact)算法

    ![image-20240112143335429](jvm.assets/image-20240112143335429.png)



- 优点

  - 此算法消除了“标记-清除”和“复制”两个算法的弊端

- 缺点

  - 从效率上来说，标记-压缩算法要低于复制算法
    - 效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址
    - 对于老年代每次都有大量对象存活的区域来说，极为负重

  - 移动过程中，需要全程暂停用户应用程序。即：STW



#### 4.4   分代收集算法

- 根据对象的存活周期将堆内存分为新生代和老年代。新生代使用复制算法，老年代使用标记-清除或标记-整理算法，**针对不同存活特性采用不同的垃圾回收算法**

  

#### 4.5 增量收集算法

- 前面四种算法，在垃圾回收都会让应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成（Stop the World）
- 为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生
- 基本思想
  - 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程**交替执行**。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成
  - 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作
- 缺点
  - 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降

#### 4.6 分区算法

- G1收集器使用的算法
- 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间
- 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间
- 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿

![image-20240112144506125](jvm.assets/image-20240112144506125.png)



### 5. 垃圾回收器分类

#### 5.1  串行垃圾回收器

-  Serial   串行垃圾回收器，它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，所以不适合服务器环境  
-  主要有
   - Serial
   - Serial Old

#### 5.2 并行垃圾回收器 

- Parallel 并行垃圾回收器，多个垃圾收集线程并行工作，此时用户线程是暂停的,适用于科学计算/大数据处理首页处理等弱交互场景
- 主要有
  - ParNew
  - Parallel Scavenge
  - Parallel Old

#### 5.3 并发垃圾收集器

-  CMS  并发垃圾收集器，用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行） 不需要停顿用户线程，适用对响应时间有要求的场景
-  主要有
   - CMS
   - G1

#### 5.4 收集器和垃圾分代之间的关系

​          ![image-20240112150023240](jvm.assets/image-20240112150023240.png)  

#### 5.5 如何查看默认垃圾收集器

- java -XX:+PrintCommandLineFlags -version 
- jinfo -flag 相关垃圾回收器参数 进程ID
- 默认并行垃圾收集器                    



### 6. 垃圾收集器落地实现

**如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现**

![image-20240110211339202](jvm.assets/image-20240110211339202.png)

#### 6.1   Serial 收集器

- 串行回收

- -XX:+UseSerialGC

#### 6.2  ParNew 收集器

- 并行回收
- Par是Parallel的缩写，New：只能处理的是新生代
- 复制算法
- -XX:+UseParNewGC

####  6.3  Parallel Scavenge 收集器

- 吞吐量优先
- 和ParNew 的区别
  - 目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器
  - 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别
- jdk8默认的垃圾回收器
- -XX:+UseParallelGC

#### 6.4   Serial Old 收集器

#### 6.5  Parallel Old 收集器 

####  6.6 CMS 收集器

- HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作

- CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-world”

- 收集过程分为四个阶段

  - 初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象
  - 并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程
  - 重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题
  - 并发清理（最耗时）

  ![image-20240112164121973](jvm.assets/image-20240112164121973.png)

- 优点
  - 并发收集
  - 低延迟
- 缺点
  - 会产生内存碎片
  - CMS收集器对CPU资源非常敏感
  - CMS收集器无法处理浮动垃圾

#### 6.7 G1 收集器

- 为啥要有G1？
  - 垃圾收集经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。G1（Garbage-First）垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。
  - 为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量
- jdk9默认的垃圾回收器
- -XX:+UseG1GC
- 特点
  - 并行与并发
    - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
    - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
  - 分代收集
    - 将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代
  - 空间整合
  - 可预测的停顿时间模型
- 垃圾回收过程
  - 年轻代GC
    - 当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
    - 年轻代垃圾回收只会回收Eden区和Survivor区
  - 并发标记过程
    - 当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器
  - 混合回收
  - FullGC

#### 6.8 ZGC 收集器

- 在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟
- ZGC：是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器
- ZGC的工作过程可以分为4个阶段：并发标记-并发预备重分配-并发重分配-并发重映射等



### 7 . STW

- Stop-the-World ，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW
- 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。
  - 分析工作必须在一个能确保一致性的快照中进行
  - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
  - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
- STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉
- 开发中不要用System.gc();会导致Stop-the-world的发生







####          

​      

​                                            
