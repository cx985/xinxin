---
icon: tag
order: 2
category:
  - 使用指南
tag:
  - java
---
# JUC
## 1、进程和线程的区别
进程可以看作一个正在运行的程序  一个进程包含多个线程
 
## 2、并发与并行的区别
并发：两个及两个以上的作业在同一时间段内执行
并行：两个及两个以上的作业在同一时刻执行
最关键的点：是否是同时执行
 
## 3、java线程的生命周期和状态
new：初始状态，线程被创建出来但没有被调用start()
runnable: 运行状态，线程被调用了start()等待运行的状态
blocked: 阻塞状态，需要等待锁释放
waiting: 等待状态，表示该线程需要等待其他线程做出一些特定动作，如通知或中断
time_waiting: 超时等待状态，可以在指定的时间后自行返回而不是像waiting那样一直等待
terminated: 终止状态，表示该线程已经运行完毕
 
## 4、死锁
线程A持有资源2，线程B持有资源1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态
 
死锁的四个必要条件
1、互斥条件：该资源任意一个时刻只由一个线程占用
2、请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放
3、不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源
4、循环等待条件: 若干线程之间形成一种头尾相接的循环等待资源关系
 
## 5、sleep() 和wait()对比
共同点：两者都可以暂停线程的执行
区别：
1、sleep() 方法没有释放锁，而wait() 方法释放了锁
2、wait() 通常被用于线程间交互，sleep()通常被用于暂停执行
3、wait()方法被调用后，线程不会自动苏醒，需要调用notify() 或者 notifyAll()方法，sleep()方法执行完成后，线程会自动苏醒，
4、sleep() 是Thread类的静态本地方法，wait() 则是Object类的本地方法
 
## 6、为什么wait()方法不定义在Thread中?
wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁，每个对象都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入waiting状态，自然是要
操作对应的对象而非当前的线程
 
## 7、为什么sleep() 方法定义在Thread中？
答：因为sleep()是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁
 
## 8、可以直接调用Thread类中的run方法吗？
答：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。
 
 
 
 
 
